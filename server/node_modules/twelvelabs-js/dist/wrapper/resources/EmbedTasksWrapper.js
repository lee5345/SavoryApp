"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbedTasksWrapper = void 0;
const Client_1 = require("../../api/resources/embed/resources/tasks/client/Client");
/**
 * Wrapper for the EmbedTasks client that adds additional functionality.
 */
class EmbedTasksWrapper extends Client_1.Tasks {
    constructor(options) {
        super(options);
    }
    /**
     * This method creates multiple video embedding tasks in bulk.
     *
     * @param {Object} request Request parameters
     * @param {string} request.modelName The name of the embedding model to use (e.g., "Marengo-retrieval-2.7").
     * @param {Array<CreateEmbeddingsTaskVideoParams>} request.videos A list of video parameters for creating embedding tasks.
     * @param {Tasks.RequestOptions} [requestOptions] Request-specific configuration.
     *
     * @returns {Promise<TwelvelabsApi.embed.TasksCreateResponse[]>} A list of video embedding tasks that were successfully created.
     *
     * @example
     *     const tasks = await client.embed.tasks.createBulk({
     *         modelName: "Marengo-retrieval-2.7",
     *         videos: [
     *             {
     *                 videoUrl: "https://example.com/video1.mp4",
     *                 videoEmbeddingScopes: ["clip", "video"]
     *             },
     *             {
     *                 videoUrl: "https://example.com/video2.mp4",
     *                 videoEmbeddingScopes: ["clip"]
     *             }
     *         ]
     *     });
     */
    createBulk(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { modelName, videos } = request;
            if (!videos || videos.length === 0) {
                throw new Error("At least one video must be provided");
            }
            const tasks = [];
            for (const videoParams of videos) {
                try {
                    const req = {};
                    if (videoParams.videoFile) {
                        req.videoFile = videoParams.videoFile;
                    }
                    if (videoParams.videoUrl) {
                        req.videoUrl = videoParams.videoUrl;
                    }
                    if (videoParams.videoStartOffsetSec !== undefined && videoParams.videoStartOffsetSec !== null) {
                        req.videoStartOffsetSec = videoParams.videoStartOffsetSec;
                    }
                    if (videoParams.videoEndOffsetSec !== undefined && videoParams.videoEndOffsetSec !== null) {
                        req.videoEndOffsetSec = videoParams.videoEndOffsetSec;
                    }
                    if (videoParams.videoClipLength !== undefined && videoParams.videoClipLength !== null) {
                        req.videoClipLength = videoParams.videoClipLength;
                    }
                    if (videoParams.videoEmbeddingScope) {
                        req.videoEmbeddingScope = videoParams.videoEmbeddingScope;
                    }
                    const task = yield this.create(Object.assign({ modelName }, req), requestOptions);
                    tasks.push(task);
                }
                catch (e) {
                    console.error(`Error creating embedding task: ${e}`);
                    continue;
                }
            }
            return tasks;
        });
    }
    /**
     * Wait for a task to complete by periodically checking its status.
     *
     * @param {string} taskId The unique identifier of the task to wait for.
     * @param {Object} [options] Options for the wait operation
     * @param {number} [options.sleepInterval=5.0] The time in seconds to wait between status checks
     * @param {Function} [options.callback] A function to call after each status check with the task response
     * @param {Tasks.RequestOptions} [requestOptions] Request-specific configuration
     *
     * @returns {Promise<TwelvelabsApi.embed.TasksStatusResponse>} The completed task response
     *
     * @throws {Error} If sleepInterval is less than or equal to 0
     *
     * @example
     *     const task = await client.embed.tasks.create({
     *         modelName: "Marengo-retrieval-2.7",
     *         videoUrl: "https://example.com/video.mp4"
     *     });
     *
     *     const completedTask = await client.embed.tasks.waitForDone(
     *         task._id,
     *         {
     *             sleepInterval: 10.0,
     *             callback: (task) => console.log(`Current status: ${task.status}`)
     *         }
     *     );
     */
    waitForDone(taskId, options, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const sleepInterval = (_a = options === null || options === void 0 ? void 0 : options.sleepInterval) !== null && _a !== void 0 ? _a : 5.0;
            const callback = options === null || options === void 0 ? void 0 : options.callback;
            if (sleepInterval <= 0) {
                throw new Error("sleepInterval must be greater than 0");
            }
            // Get initial task
            let task = yield this.status(taskId, requestOptions);
            // Check if it's already done
            const doneStatuses = ["ready", "failed"];
            // Continue checking until it's done
            while (!task.status || doneStatuses.indexOf(task.status) === -1) {
                yield new Promise((resolve) => setTimeout(resolve, sleepInterval * 1000));
                try {
                    task = yield this.status(taskId, requestOptions);
                }
                catch (e) {
                    console.error(`Retrieving task status failed: ${e}. Retrying...`);
                    continue;
                }
                if (callback) {
                    const result = callback(task);
                    if (result instanceof Promise) {
                        yield result;
                    }
                }
            }
            return task;
        });
    }
}
exports.EmbedTasksWrapper = EmbedTasksWrapper;
